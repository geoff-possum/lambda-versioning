{
  "AWSTemplateFormatVersion": "2010-09-09",
  "Description": "Lambda functions for Custom Resources to create Lambda Versions",
  "Parameters": {
    "LoggingTTL" : {
      "Default" : 7,
      "Description" : "The TTL in days for the logs generated by the Lambda functions",
      "Type" : "Number",
      "AllowedValues" : [1, 3, 5, 7, 14, 30, 60, 90, 120, 150, 180, 365, 400, 545, 731, 1827, 3653]
    }
  },
  "Resources": {
    "CodeHashLambda": {
      "Properties": {
        "Code": {
          "ZipFile": {
            "Fn::Join": [
              "\n",
              [
                "import boto3",
                "from botocore.vendored import requests",
                "from hashlib import sha512",
                "import json",
                "from uuid import uuid4",
                "",
                "def send(event, context, response_status, Reason=None, ResponseData=None, PhysicalResourceId=None):",
                "  response_url = event.get('ResponseURL', \"\")",
                "  json_body = json.dumps({",
                "    'Status' : response_status,",
                "    'Reason' : Reason or 'See the details in CloudWatch Log Stream: ' + context.log_stream_name,",
                "    'PhysicalResourceId' :  PhysicalResourceId or context.log_stream_name,",
                "    'StackId' : event.get('StackId', \"\"),",
                "    'RequestId' : event.get('RequestId', \"\"),",
                "    'LogicalResourceId' : event.get('LogicalResourceId', \"\"),",
                "    'NoEcho' : True,",
                "    'Data' : ResponseData})",
                "  headers = {",
                "    'content-type' : '',",
                "    'content-length' : str(len(json_body))",
                "  }",
                "  try:",
                "    print json_body",
                "    response = requests.put(response_url,data=json_body,headers=headers)",
                "    print(\"Status code: \" + response.reason)",
                "  except Exception as e:",
                "    print(\"Failed to send response to CFN: error executing requests.put: \" + str(e))",
                "",
                "def hash(code_object):",
                "    m = sha512()",
                "    m.update(bytes(code_object))",
                "    return m.hexdigest()",
                "",
                "def build_lambda_object(properties):",
                "    code = {}",
                "    if properties.get('ZipFile', ''):",
                "      code['ZipFile'] = properties['ZipFile']",
                "    else:",
                "      code = {",
                "        'S3Bucket' : properties.get('S3Bucket', ''),",
                "        'S3Key' : properties.get('S3Key', ''),",
                "        'S3ObjectVersion' : properties.get('S3ObjectVersion', '')",
                "      }",
                "    return {",
                "      'Code': code,",
                "      'DeadLetterConfig': properties.get('DeadLetterConfig', {}),",
                "      'Description': properties.get('Description', ''),",
                "      'Environment': properties.get('Environment', { 'Variables' : {} } ),",
                "      'Handler': properties.get('Handler', ''),",
                "      'KmsKeyArn': properties.get('KmsKeyArn', ''),",
                "      'Layers': properties.get('Layers', []),",
                "      'MemorySize': properties.get('MemorySize', ''),",
                "      'ReservedConcurrentExecutions': properties.get('ReservedConcurrentExecutions', 5),",
                "      'Role': properties.get('Role', ''),",
                "      'Runtime': properties.get('Runtime', ''),",
                "      'Timeout': properties.get('Timeout', ''),",
                "      'TracingConfig': properties.get('TracingConfig', { 'Mode' : 'PassThrough' } ),",
                "      'VpcConfig': properties.get('VpcConfig', {})",
                "    }",
                "",
                "def get_hash(properties, text):",
                "    try:",
                "        info = build_lambda_object(properties)",
                "        code_hash = hash(info)",
                "        return (",
                "            True, ",
                "            { ",
                "                'Code': info['Code'],",
                "                'CodeHash': code_hash,",
                "                'DeadLetterConfig': info['DeadLetterConfig'],",
                "                'Description': info['Description'],",
                "                'Environment': info['Environment'],",
                "                'Handler': info['Handler'],",
                "                'KmsKeyArn': info['KmsKeyArn'],",
                "                'Layers': info['Layers'],",
                "                'MemorySize': info['MemorySize'],",
                "                'ReservedConcurrentExecutions': info['ReservedConcurrentExecutions'],",
                "                'Role': info['Role'],",
                "                'Runtime': info['Runtime'],",
                "                'Timeout': info['Timeout'],",
                "                'TracingConfig': info['TracingConfig'],",
                "                'VpcConfig': info['VpcConfig']",
                "            },",
                "            \"{} Successful\".format(text)",
                "        )",
                "    except Exception as e:",
                "        print e",
                "        return (False, {}, \"Error during {}: {}\".format(text, e))",
                "",
                "def lambda_handler(event, context):",
                "  print event",
                "  properties = event.get('ResourceProperties', {})",
                "  physical_resource_id = str(uuid4())",
                "  data = {}",
                "  req_type = event.get('RequestType', \"\")",
                "  if req_type == 'Create':",
                "    res, data, reason = get_hash(properties, \"Create\")",
                "  elif req_type == 'Update':",
                "    res, data, reason = get_hash(properties, \"Update\")",
                "  elif req_type == 'Delete':",
                "    physical_resource_id = properties.get('PhysicalResourceId', '')",
                "    res = True",
                "    reason = \"Delete Successful\"",
                "  else:",
                "    res = False",
                "    reason = \"Unknown operation: \" + req_type",
                "  status = \"FAILED\"",
                "  if res:",
                "    status = \"SUCCESS\"",
                "  send(event, context, status, Reason=reason, ResponseData=data, PhysicalResourceId=physical_resource_id)"
              ]
            ]
          }
        },
        "Description": "Generates SHA512 hash of provide Lambda Code details",
        "Handler": "index.lambda_handler",
        "MemorySize": 128,
        "Role": { "Fn::GetAtt": [ "CodeHashRole", "Arn" ] },
        "Runtime": "python2.7",
        "Timeout": 60
      },
      "Type": "AWS::Lambda::Function"
    },
    "CodeHashVersion" : {
      "Type" : "AWS::Lambda::Version",
      "Properties" : {
          "FunctionName" : { "Fn::GetAtt" : [ "CodeHashLambda", "Arn" ] }
      }
    },
    "CodeHashRole" : {
      "Type": "AWS::IAM::Role",
      "Properties": {
        "AssumeRolePolicyDocument": {
          "Version": "2012-10-17",
          "Statement": [
            {
              "Effect": "Allow",
              "Principal": {
                "Service": "lambda.amazonaws.com"
              },
              "Action": "sts:AssumeRole"
            }
          ]
        },
        "ManagedPolicyArns" : [ 
          "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole" 
        ],
        "Path": "/"      
      }
    },
    "CodeHashLogGroup" : {
      "Type" : "AWS::Logs::LogGroup",
      "Properties" : {
          "LogGroupName" : { "Fn::Sub" : "/aws/lambda/${CodeHashLambda}" },
          "RetentionInDays" : { "Ref" : "LoggingTTL" }
      }
    },
    "VersionCreatorLambda": {
      "Properties": {
        "Code": {
          "ZipFile": {
            "Fn::Join": [
              "\n",
              [
                "import boto3",
                "from botocore.vendored import requests",
                "import json",
                "from uuid import uuid4",
                "",
                "def send(event, context, response_status, Reason=None, ResponseData=None, PhysicalResourceId=None):",
                "  response_url = event.get('ResponseURL', \"\")",
                "  json_body = json.dumps({",
                "    'Status' : response_status,",
                "    'Reason' : Reason or 'See the details in CloudWatch Log Stream: ' + context.log_stream_name,",
                "    'PhysicalResourceId' :  PhysicalResourceId or context.log_stream_name,",
                "    'StackId' : event.get('StackId', \"\"),",
                "    'RequestId' : event.get('RequestId', \"\"),",
                "    'LogicalResourceId' : event.get('LogicalResourceId', \"\"),",
                "    'NoEcho' : True,",
                "    'Data' : ResponseData})",
                "  headers = {",
                "    'content-type' : '',",
                "    'content-length' : str(len(json_body))",
                "  }",
                "  try:",
                "    print json_body",
                "    response = requests.put(response_url,data=json_body,headers=headers)",
                "    print(\"Status code: \" + response.reason)",
                "  except Exception as e:",
                "    print(\"Failed to send response to CFN: error executing requests.put: \" + str(e))",
                "",
                "def new_version(lambda_arn, text):",
                "  try:",
                "    client = boto3.client('lambda')",
                "    return (",
                "      True, ",
                "      { \"VersionArn\": \"{}:{}\".format(lambda_arn, client.publish_version(FunctionName=lambda_arn)[\"Version\"]) }, ",
                "      \"{} Successful\".format(text)",
                "    )",
                "  except Exception as e:",
                "    print e",
                "    return (False, \"\", \"Error during {}: {}\".format(text, e))",
                "",
                "def lambda_handler(event, context):",
                "  print event",
                "  properties = event.get('ResourceProperties', {})",
                "  arn = properties.get('LambdaFunctionArn', \"\")",
                "  physical_resource_id = str(uuid4())",
                "  data = {}",
                "  req_type = event.get('RequestType', \"\")",
                "  if req_type == 'Create':",
                "    res, data, reason = new_version(arn, \"Create\")",
                "  elif req_type == 'Update':",
                "    res, data, reason = new_version(arn, \"Update\")",
                "  elif req_type == 'Delete':",
                "    physical_resource_id = properties.get('PhysicalResourceId', '')",
                "    res = True",
                "    reason = \"Delete Successful\"",
                "  else:",
                "    res = False",
                "    reason = \"Unknown operation: \" + req_type",
                "  status = \"FAILED\"",
                "  if res:",
                "    status = \"SUCCESS\"",
                "  send(event, context, status, Reason=reason, ResponseData=data, PhysicalResourceId=physical_resource_id)",
              ]
            ]
          }
        },
        "Description": "Creates new Lambda Version for a Lambda Function",
        "Handler": "index.lambda_handler",
        "MemorySize": 128,
        "Role": { "Fn::GetAtt": [ "VersionCreatorRole", "Arn" ] },
        "Runtime": "python2.7",
        "Timeout": 60
      },
      "Type": "AWS::Lambda::Function"
    },
    "VersionCreatorVersion" : {
      "Type" : "AWS::Lambda::Version",
      "Properties" : {
          "FunctionName" : { "Fn::GetAtt" : [ "VersionCreatorLambda", "Arn" ] }
      }
    },
    "VersionCreatorRole" : {
      "Type": "AWS::IAM::Role",
      "Properties": {
        "AssumeRolePolicyDocument": {
          "Version": "2012-10-17",
          "Statement": [
            {
              "Effect": "Allow",
              "Principal": {
                "Service": "lambda.amazonaws.com"
              },
              "Action": "sts:AssumeRole"
            }
          ]
        },
        "ManagedPolicyArns" : [ 
          "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole" 
        ],
        "Path": "/",
        "Policies": [
          {
            "PolicyName": "CreateVersion",
            "PolicyDocument": {
              "Version": "2012-10-17",
              "Statement": [
                {
                  "Action": [
                    "lambda:PublishVersion"
                  ],
                  "Resource": "*",
                  "Effect": "Allow"
                }
              ]
            }
          }
        ]
      }
    },
    "VersionCreatorLogGroup" : {
      "Type" : "AWS::Logs::LogGroup",
      "Properties" : {
          "LogGroupName" : { "Fn::Sub" : "/aws/lambda/${VersionCreatorLambda}" },
          "RetentionInDays" : { "Ref" : "LoggingTTL" }
      }
    }
  },
  "Outputs": {
    "CodeHashLambdaVersion": {
      "Description": "Arn of the Code Hash Lambda Version available for Custom Resources",
      "Value": { "Ref": "CodeHashVersion" },
      "Export": { "Name" : { "Fn::Sub" : "${AWS::StackName}-CodeHash" } }
    },
    "VersionCreatorLambdaVersion": {
      "Description": "Arn of the Version Creator Lambda Version available for Custom Resources",
      "Value": { "Ref": "VersionCreatorVersion" },
      "Export": { "Name" : { "Fn::Sub" : "${AWS::StackName}-VersionCreator" } }
    }
  }
}
